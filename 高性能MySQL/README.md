## 高性能 MySQL

### MySQL 架构和历史
- MySQL 最重要的特性是它的存储引擎架构，这种架构的设计将查询处理（Query Processing）及其他系统任务（Server Task）与数据的存储/提取相分离。这种**处理和存储分离**的设计可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。
- 每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个 CPU 核心或者 CPU 中运行。服务器会负责缓存该线程，因此不需要为每一个新建的连接创建或销毁线程。
- MySQL 在两个层面有并发控制：服务器层和存储引擎层
- MySQL 中两种最重要的锁策略：
  - **表锁**（table lock）：锁定整张表。尽管存储引擎可以管理自己的锁，MySQL 本身还是会使用各种有效的表锁来实现不同的目的（例如，服务器会为诸如 `ALTER TABLE` 之类的语句使用表锁，而忽略存储引擎的锁机制）
  - **行级锁**（row lock）：可以最大程度地支持并发处理（同时也带来了最大的锁开销），**行级锁只在存储引擎层实现**
- 隐式和显式锁定
  - InnoDB 采用的是**两阶段锁定协议**（two-phase locking protocol）。在事务的执行过程中，随时都可以执行锁定，锁只有在执行 `COMMIT` 或者 `ROLLBACK` 的时候才会释放，并且所有的锁在同一时刻被释放。InnoDB 会根据隔离级别在需要的时候自动加锁（隐式锁定）
  - InnoDB 显式锁定：
    ```sql
    SELECT ... LOCK IN SHARE MODE -- 共享锁
    SELECT ... FOR UPDATE
    ```
  - MySQL 支持 `LOCK TABLES` 和 `UNLOCK TABLES`，在服务器层实现，与存储引擎无关。
  - 建议：除了事务中禁用了 `AUTOCOMMIT`，可以使用 `LOCK TABLES` 之外，其他任何时候都不要显式地执行 `LOCK TABLES`，不管使用什么存储引擎。
- 事务：MySQL 服务器层不管理事务，事务是由下层的存储引擎实现的。
  - **原子性**（Atomicity）：事务不可分割
  - **一致性**（Consistency）：事务的行为总是一致的
  - **隔离性**（Isolation）：事务所做的修改在提交以前，对其他事务是不可见的
  - **持久性**（Durability）：一旦事务提交，其所做的修改就会永久保存到数据库中（即使系统崩溃）
- 并发操作产生的数据不一致性：
  - **丢失修改**：一个事务的修改被另一个事务**覆盖**
  - **脏读**：事务 T1 修改数据但未提交，事务 T2 读取同一数据，T1 又**撤销修改**，此时 T2 读到的数据与实际存储的数据不一致
  - **不可重复读**：事务 T1 读取数据后，T2 **更新**了数据，使 T1 无法再现前一次读取的结果
  - **幻读**：事务 T1 读取数据后，T2 执行了**插入/删除**，使 T1 一次事务多次查询中，结果集数量不一致（幻行）
- 隔离级别：较低的隔离级别通常可以执行更高的并发，系统的开销也更低。MySQL 修改隔离级别命令：`SET SESSION TRANSACTION ISOLATION LEVEL ...`
  - **未提交读**（READ UNCOMMITTED）：事务可以读取未提交的数据。**会存在脏读、不可重复读、幻读的问题**
  - **提交读**（READ COMMITTED）：大多数数据库系统的默认隔离级别（MySQL 不是），一个事务在提交之前，所做的任何修改都是对其他事务不可见的（通过写锁）。**会存在不可重复读、幻读的问题**
  - **可重复读**（REPEATABLE READ）：该级别保证了在同一个事务中多次读取同样记录的结果是一致的。**会存在幻读的问题**，InnoDB 和 XtraDB 存储引擎通过**多版本并发控制**解决了幻读的问题。**该级别是 MySQL 的默认事务隔离级别**
  - **可串行化**（SERIALIZABLE）：强制事务串行执行，是最高的隔离级别，可以避免幻读，它会在读取的每一行数据上都加上锁。
- 死锁：数据库系统实现了各种死锁检测和死锁超时机制。InnoDB 处理死锁的方式为：将持有最少行级排他锁的事务进行回滚
- 事务日志：使用事务日志，**存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘**。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的**顺序 I/O**，而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多（日志中记录的是动作而不是数据）。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为**预写式日志**（Write-AheadLogging），**修改数据需要写两次磁盘**。
- 多版本并发控制（MVCC）：可以认为其是行级锁的一个变种，但在很多情况下避免了加锁操作，因此开销更低。它的实现，是通过保存数据在某个时间点的**快照**来实现的。也就是说，不管需要执行多长时间，同一事务看到的数据都是一致的；根据事务开始时间的不同，每个事务对同一张表，同一时刻看到的数据可能是不同的。
  - 乐观并发控制
  - 悲观并发控制
  - InnoDB 的 MVCC：通过在每行记录后面保存两个隐藏的列，一个是行的创建时间，另一个是行的保存时间（删除时间），这里的时间指的是系统版本号，每开始一个新的事务，系统版本号都会递增，事务开始时刻的系统版本号会作为该系统的版本号，用来和查询到的每行记录的版本号进行比较。写操作在事务提交后才可见。在**可重复读**的隔离级别下，InnoDB 的 MVCC 具体操作为：
    - SELECT：
      - 每行记录的系统版本号 `<=` 事务的版本号（保证事务开始时该行已存在、或者是事务自身插入/修改的）
      - 每行记录的删除版本号要么未定义，要么 `>` 事务的版本号（确保事务读取到的行，在事务开始之前未被删除）
    - INSERT：
      - 为新插入的每一行保存当前事务版本号为行版本号
    - DELETE：
      - 为删除的每一行保存当前事务版本号为行删除版本号
    - UPDATE：
      - 插入一条新纪录，保存当前事务版本号为该新纪录的行版本号
      - 对于旧记录，保存当前事务版本号为行删除版本号
    - 优点：大多数读操作不用加锁
    - 缺点：每行记录都需要额外的存储空间，需要做更多的行检查，以及一些额外的维护工作
  - MVCC 只在**提交读（读取最新版本）**、**可重复读（读取当前版本）**这两个隔离级别下工作，因为**未提交读**永远读取最新的数据行、**可串行化**对每个读取的行都加锁
- 存储引擎
  - InnoDB：MySQL 的默认事务型引擎，被设计用来处理大量的短期事务。
    - 采用 MVCC 来支持高并发，并且实现了四种隔离级别，默认为**可重复读**。通过**间隙锁**（next-key locking）策略防止幻读的出现。间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
    - InnoDB 表是基于**聚簇索引**建立的，对主键查询有很高的性能，但它的二级索引（secondary index，非主键索引）必须包含主键列，因此如果主键列很大的话，其他的所有索引都会很大（若表索引很多，主键应尽量小）。
    - 内部优化：从磁盘读取数据采用**可预测性预读**；自动在内存中创建用以加速读操作的**自适应哈希索引**；用于加速插入操作的**插入缓冲区**等
  - MyISAM：不支持事务、行级锁；拥有全文索引、压缩、空间函数（GIS）等
    - 延迟更新索引键：通过指定 `DELAY_KEY_WRITE` 选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种方式可以极大地提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏
    - 加锁与并发：对整张表加锁。读取时加共享锁、写入时加排他锁；但有表在查询时，也可以同时插入（并发插入）
    - MyISAM 只将数据写到内存中，然后等待操作系统定期将数据刷出到磁盘上